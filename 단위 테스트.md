# 단위 테스트

## 2. 단위 테스트란 무엇인가?
### 2.1.1 격리 문제에 대한 `런던파`의 접근
- 클래스의 모든 의존성은 테스트 대역으로 대체됐기 때문에, 테스트가 실패하면 확실하게 테스트 대상 시스템(SUT)가 고장남을 알 수 있다
- SUT의 의존성을 테스트 대역으로 대체하면, 객체 그래프를 분할할 수 있다
    - 그래프를 효과적으로 분해해 단위 테스트에서 준비를 크게 줄일 수 있다
```java
public void Purchase_succeeds_when_enough_inventory() {
    
    // 준비
    var storeMock = new Mock<ISTORE>();
    storeMock
            .Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
            .Returns(true);
    var customer = new Customer();
    
    // 실행
    bool success = customer.Purchase(
            storeMock.Object, Product.Shampoo, 5);

    // 검증
    Assert.True(success);
    storeMock.Verify(
        x => x.RemoveInventory(Product.Shampoo, 5),
        Times.Once);
}
```
- `Mock`을 사용해 대체

### 2.1.2 격리 문제에 대한 `고전파`의 접근
```java
public void Purchase_succeeds_when_enough_inventory() {
    
    // 준비
    var store = new Store();
    store.AddInventory(Product.Shampoo, 10);
    var customer = new Customer();
    
    // 실행
    bool success = customer.Purchase(store, Product.Shampoo, 5);

    // 검증
    Assert.True(success);
    Assert.Equal(5, store.GetInventory(Product.Shampoo));
}
```
- Mock을 사용하지 않고 `운영용 인스턴스`를 사용
- `Customer`, `Store` 둘 다 검증

### 공유 의존성
- 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성
- 정적 가변 필드, 데이터베이스 등
### 비공개 의존성
- 공유하지 않는 의존성
- Configuration Class 등

![스샷](https://user-images.githubusercontent.com/26949623/167300965-6814b92e-5f7e-4154-80d0-c53a3fba356c.png)


## 2.2 단위 테스트의 런던파와 고전파

|-|격리 주체|단위의 크기|테스트 대역 사용 대상|
|---|---|---|---|
|런던파|단위|단일 클래스|불변 의존성 외 모든 의존성|
|고전파|단위 테스트|단일 클래스 또는 클래스 세트|공유 의존성|
### 2.2.1 고전파와 런던파가 의존성을 다루는 방법
![스샷](https://user-images.githubusercontent.com/26949623/167300971-2fbf93b7-4cbb-4790-9368-8d9460c62b16.png)

|-|의존성 종류|
|---|---|
|데이터 베이스|공유 의존성|
|Store 인스턴스|변경 가능한 비공개 의존성|
|Product 인스턴스|불변 비공개 의존성(값 객체, Value Object)|

![스샷](https://user-images.githubusercontent.com/26949623/167300972-5c169700-6010-4367-9344-507e0d8a266c.png)
- 읽기 전용 API 서비스는 공유 의존성이 아니다
    - 쓰기 API 서비스는 공유 의존성이다

## 2.3 고전파와 런던파 비교
### 2.3.1 한 번에 한 클래스만 테스트하기
> 좋은 테스트는 `단일 동작 단위`를 검증해야 한다<br>
> 테스트는 해결하는 데 도움이 되는 문제에 대한 이야기를 들려줘야 한다<br>
> 이 이야기는 프로그래머가 아닌 `일반 사람들`에게 응집도 높고 의미가 있어야 한다

- 테스트는 코드의 단위를 검증해서는 안 된다
- `동작의 단위`, 즉 문제 영역에 의미가 있는 것, 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다
- 동작 단위를 구현하는 데 클래스가 얼마나 필요한지는 상관없다
- 단위는 여러 클래스에 걸쳐 있거나 한 클래스에만 있을 수 있고, 심지어 아주 작은 메소드가 될 수도 있다
- 예
    - 우리집 강아지를 부르면, 바로 나에게 온다
    - 우리집 강아지를 부르면 먼저 왼쪽 앞다리를 움직이고, 이어서 오른쪽 앞다리를 움직이고, 머리를 돌리고, 꼬리를 흔들기 시작한다.....
### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기
- 실제 협력자를 대신해 Mock을 사용하면 클래스를 쉽게 테스트할 수 있다
- 클래스의 직접적인 의존성을 대체해 그래프를 나눌 수 있으며, 이는 단위 테스트에서 준비해야 할 작업량을 크게 줄일 수 있다
<br><br>
> 위는 모두사실이지만, 이 추리 과정은 잘못된 초점을 맞추고 있다
- 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다
- 대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과다
- Mock을 사용하는 것은 이 문제를 감추기만 할 뿐, 원인을 해결하지 못한다
## 2.4 두 분파의 통합 테스트
- 런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다
    - 고전 스타일로 작성된 대부분의 테스트는 런던파 지지자들에게 통합 테스트로 느껴질 것
### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트
- 엔드 투 엔드 테스트가 일반적으로 의존성을 더 많이 포함한다

![스샷](https://user-images.githubusercontent.com/26949623/167300974-39901d67-e489-4280-87e3-9db8c13cc54f.png)

## 3. 단위 테스트 구조
## 3.1 단위 테스트를 구성하는 방법
### 3.1.1 AAA 패턴 사용
> AAA 패턴은 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움
- 준비
  - SUT와 해당 의존성을 원하는 상태로 만든다
- 실행
  - SUT 메소드를 호출하고 준비된 의존성을 전달
  - 출력이 있다면 출력 값을 캡처
- 검증
  - 반환 값이나 SUT와 협력자의 최종 상태
  - SUT가 협력자에 호출한 메소드
- 검증구절부터 시작
  > TDD를 실천할 떄, 즉 기능을 개발하기 전에 실패할 테스트를 만들 때는 어떻게 동작할지 충분히 알지 못한다<br>
  > 따라서 먼저 기대하는 동작으로 윤곽을 잡은 다음, 이 기대에 부응하기 위한 시스템을 어떻게 개발할지 아는 것이 좋다
- 준비구절부터 시작
  > 제품 코드를 작성한 후에 테스트를 작성한다면 테스트를 작성할 시점에 실행에서 무엇을 예상하는지 이미 알고 있으므로 준비 구절부터 시작하는 것이 좋다
### 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기
> 여러 개의 준비, 실행, 검증 구절은 테스트가 너무 많은 것을 한 번에 검증한다는 의미<br>
> 이러한 테스트는 여러 테스트로 나눠서 해결
- 실행이 하나면 테스트가 단위 테스트 범주에 있게끔 보장하고, 간단하고, 빠르며, 이해하기 쉽다
- 통합 테스트에서는 실행 구절을 여러 개 두는 것이 괜찮을 때도 있다
### 3.1.3 테스트 내 if 문 피하기
- 단위 테스트든 통합 테스트든 분기가 없는 간단한 일력의 단계여야 한다
### 3.1.4 각 구절은 얼마나 커야 하는가?
- 일반적으로 준비 구절이 세 구절 중 가장 크다
  - 준비 구절이 많이 크면, 별로로 도출하는 것이 좋다
- 실행 구절은 보통 코드 `한 줄`이다
  ```java
  public void Purchase_succeeds_when_enough_inventory() {
      
      // 준비
      var store = new Store();
      store.AddInventory(Product.Shampoo, 10);
      var customer = new Customer();
      
      // 실행
      bool success = customer.Purchase(store, Product.Shampoo, 5);
      store.RemoveInventory(success, Product.Shampoo, 5);
  
      // 검증
      Assert.True(success);
      Assert.Equal(5, store.GetInventory(Product.Shampoo));
  }
  ```
  - 위 테스트의 문제점은 단일 작업을 수행하는 데 `두 개`의 메소드 호출이 필요하다는 것
  - 비즈니스 관점에서 구매가 `정상`적으로 이뤄지면 `고객의 제품 획득`과 `매장 재고 감소`라는 `두 가지` 결과를 얻는다
  - 이 결과는 `같이` 만들어야 하고, 이는 다시 단일한 메소드가 있어야 한다는 뜻
  - `코드 캡슐화`를 항상 지켜서 해결할 수 있다
### 3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가
- 단위 테스트의 단위는 `동작의 단위`이지 코드의 단위가 아니다
  - 단일 동작 단위는 여러 결과를 낼 수 있으며, 하나의 테스트로 그 모든 결과를 평가하는 것이 좋다
### 3.1.6 테스트 대상 시스템 구별하기
- SUT과 의존성을 구분
- 테스트 내 SUT 이름을 `sut`로 하라
  
