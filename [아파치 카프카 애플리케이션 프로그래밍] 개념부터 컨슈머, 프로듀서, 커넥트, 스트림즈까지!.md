# [아파치 카프카 애플리케이션 프로그래밍] 개념부터 컨슈머, 프로듀서, 커넥트, 스트림즈까지!

## 카프카 기본 개념 설명
### 카프카 생태계
![스크린샷 2022-06-19 오후 5.11.26.png](https://github.zendesk.com/attachments/token/ELx9AQgdL32PL5Xo4ABSo1740/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+5.11.26.png)
### 카프카 브로커와 클러스터
![스크린샷 2022-06-19 오후 5.18.45.png](https://github.zendesk.com/attachments/token/5rNmqoaGSS8iE4aQMbKSXgNPG/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+5.18.45.png)
- 서버 한대에 브로커 한대 운영
- 브로커 3대 이상을 클러스터로 묶어서 운영
### 카프카 클러스터와 주키퍼
![스크린샷 2022-06-19 오후 5.22.12.png](https://github.zendesk.com/attachments/token/FiEpnJ72LdDnk1OLGbza13K29/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+5.22.12.png)
- 카프카 클러스터를 실행하기 위해서는 `주키퍼`가 필요
- 주키퍼 앙상블을 통해 여러 카프카 클러스터 운영가능
- 주키퍼의 서로 다른 `znode`에 클러스터를 지정
- root znode에 각 클러스터별 znode를 생성하고 클러스터 실행시 root가 아닌 하위 znode로 설정
- 카프카 3.0 부터는 주키퍼 없이도 클러스터 동작 가능
### 카프카 브로커의 역할
- 컨트롤러
    - 클러스터의 여러 브로커 중 한 대가 컨트롤러 역할
    - 다른 브로커들의 상태를 체크 > 브로커가 클러스터에서 빠지는 경우, 해당 브로커에 존재하는 리더 파티션을 나머지 브로커로 재분배
    - 컨트롤러 역할을 하는 브로커에 장애가 생기면 다른 브로커가 컨트롤러 역할
- 데이터 삭제
    - 컨슈머나 프로듀서가 데이터 삭제를 요청할 수 없다
    - 오직 브로커만이 데이터 삭제 가능
    - 데이터 삭제는 파일 단위(`로그 세그먼트`) > 세그먼트는 일반적인 데이터베이스처럼 특정 데이터를 선별해서 삭제 불가
- 컨슈머 오프셋 저장
    - `__consumer_offsets` 토픽에 오프셋 저장
    - 이 토픽은 자동으로 생성
- 그룹 코디네이터
    - 리밸런싱
    - 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배
    - 컨슈머 그룹에서 컨슈머가 빠지면 매칭되지 않은 파티션을 정상 동작하는 컨슈머로 할당
### 브로커 로그와 세그먼트
- 데이터 저장
    - config/server.properties > log.dir 옵션에 정의한 디렉토리에 데이터 저장
    - `토픽 이름-파티션 번호` 조합으로 하위 디렉토리 생성해서 데이터 저장
        ```shell
        $ ls /tmp/kafka-logs
        __consumer_offsets-0    __consumer_offsets-21
        ...
        
        >> hello.kafka 토픽의 0번 파티션
        $ ls /tmp/kafka-logs/hello.kafka-0
        0000000000000000.index  0000000000000000.log
        0000000000000000.timeindex  leader-epoch-checkpoint
        ```
        - log
            - 메시지와 메타데이터
        - index
            - 메시지의 오프셋을 인덱싱한 정보
        - timeindex
            - 메시지에 포함된 timestamp 값을 기준으로 인덱싱한 정보
- 세그먼트
```shell
$ ls /tmp/kafka-logs/hello.kafaka-0
0000000000000000.log
0000000000000010.log
0000000000000020.log
```
![스크린샷 2022-06-19 오후 6.00.45.png](https://github.zendesk.com/attachments/token/md0v3HZ8a5KQA06H2cCspdL0N/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+6.00.45.png)
- `log.segment.bytes`
    - 바이트 단위의 최대 세그먼트 크기 지정. 기본값 1GB
- `log.roll.ms(hours)`
    - 세그먼트가 신규 생성된 이후 다음 파일로 넘어가는 시간 주기. 기본값은 7일
    - 최대 세그먼트가 다 안차도 주기가 되면 다음으로 넘어감
- 액티브 세그먼트는 삭제 대상에서 제외
- 액티브 세그먼트가 아닌 일반 세그먼트는 `retention` 옵션에 따라 삭제 대상으로 지정
### 세그먼트와 삭제주기
- `cleanup.policy=delete`
    - retention.ms(minutes, hours) : 세그먼트를 보유할 최대 기간. 기본값 7일
    - retention.bytes : 파티션당 로그 적재 바이트 값. 기본값은 -1(지정하지 않음)
    - log.retention.check.interval.ms : 세그먼트가 삭제 영역에 들어왔는지 확인하는 간격. 기본값은 5분
- `cleanup.policy=compact`
![스크린샷 2022-06-19 오후 6.24.34.png](https://github.zendesk.com/attachments/token/VKSnx1gD58GsiIQ0BhSVNb746/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+6.24.34.png)
    - 동일 메시지 키에 대해 오래된 데이터를 삭제
    - 액티브 세그먼트를 제외한 세그먼트가 대상
    
    ![스크린샷 2022-06-19 오후 6.32.12.png](https://github.zendesk.com/attachments/token/EH8t6CN5lRVndjcJYBpcgjtWG/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+6.32.12.png)
    - 테일 : 압축 정책에 의해 압축이 완료된 레코드. 클린로그
    - 헤드 : 압축 정칙애 되기 전 레코드. 더티로그
    
    ![스크린샷 2022-06-19 오후 6.35.03.png](https://github.zendesk.com/attachments/token/X8gw2YVHlhri6uvO7ydbTftDN/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+6.35.03.png)
    - `min.cleanable.dirty.ratio`
        - 액티브 세그먼트를 제외한 세그먼트에 남아있는 테일 영역 레코드 수와 헤드 영역 레코드 수의 비율
### 복제(replication)
![스크린샷 2022-06-19 오후 8.44.11.png](https://github.zendesk.com/attachments/token/IK2sVVhMP39M4pGI5phG4qdjc/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+8.44.11.png)
- `replication factor` min : 1 , max : 브로커개수
- 프로듀서, 컨슈머는 only `리더` 파티션과 통신
- 팔로워 파티션들은 리더 파티션과 오프셋 차이를 확인하여 데이터를 복제
- 리더 파티션이 장애로 다운되면 팔로워 파티션 중 하나가 리더로 승급
### ISR(In-Sync-Replicas)
> 리더 파티션과 팔로워 파티션 모두 싱크된 상태

![스크린샷 2022-06-19 오후 8.57.00.png](https://github.zendesk.com/attachments/token/X1bjy98NbEbSHhQEhfvZEXOfA/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+8.57.00.png)

> 팔로워 파티션이 리더 파티션 데이터를 모두 복제하지 못한 상태에서<br>
> 리더 파티션이 다운되어 팔로우 파티션이 리더로 승급되면<br>
> 데이터 유실이 발생할 수 있다

![스크린샷 2022-06-19 오후 8.57.10.png](https://github.zendesk.com/attachments/token/oiZYZfswetZadjbjGtRlHrRc7/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+8.57.10.png)
- `unclean.leader.election.enable`=true : 유실을 감수함. 복제가 안된 팔로워 파티션을 리더로 승급
- `unclean.leader.election.enable`=false : 유실을 감수하지 않음. 리더 파티션이 복구될 때까지 대기

> 복제로 인해 데이터 저장 개수 차이가 발생할 수 있는데 <br>
> 컨슈머는 `min.insync.replicas` 설정값 이상으로 복제된 레코드를 가져간다

![스크린샷 2022-06-19 오후 8.57.20.png](https://github.zendesk.com/attachments/token/QnIDIba3vs159btLWDm0qri1n/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+8.57.20.png)
- `하이 워터마크`
    - min.insync.replicas 개수 만큼 복제가 완료되어 컨슈머가 가져갈 수 있는 레코드의 오프셋 번호
### 토픽과 파티션
![스크린샷 2022-06-19 오후 9.16.55.png](https://github.zendesk.com/attachments/token/vqG40m2zpW9zpfRbzLAF9Ky3Q/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+9.16.55.png)
- 토픽은 1개 이상의 파티션을 소유
  
![스크린샷 2022-06-19 오후 9.17.13.png](https://github.zendesk.com/attachments/token/Jrk7gPUCBG73hxt2HAcVe9ZTg/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+9.17.13.png)
- 토픽을 생성할 때, `round-robin` 방식으로 각 브로커에 리더 파티션이 할당
    - 여러 브로커와 골고루 네트워크 통신

![스크린샷 2022-06-19 오후 9.17.30.png](https://github.zendesk.com/attachments/token/mKBb6HEXbH4W3qgFEnB91hN45/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+9.17.30.png)
- 특정 브로커에 리더 파티션이 볼리면 `kafka-reassign-partition.sh` 으로 파티션 재분배

![스크린샷 2022-06-19 오후 9.17.40.png](https://github.zendesk.com/attachments/token/yGmH1HuiGnbChjRhJMqYDnpsA/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+9.17.40.png)
- 파티션 : 컨슈머 = 1 : 1 :white_check_mark:
- 파티션 : 컨슈머 = N : 1 :white_check_mark:
- 파티션 : 컨슈머 = 1 : N :x:
    - 파티션 개수는 그대로인데 컨슈머만 늘린다고 처리량이 늘어나지 않는다

![스크린샷 2022-06-19 오후 9.17.47.png](https://github.zendesk.com/attachments/token/oj63iT3oxa6IdiVuS2ItNZ5GL/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+9.17.47.png)
- 파티션을 줄이는것은 불가능
### 레코드
![스크린샷 2022-06-19 오후 9.56.21.png](https://github.zendesk.com/attachments/token/kkLhJaucynmFZmXczSDyMK288/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+9.56.21.png)
- timestamp
    - `message.timestamp.type` 토픽 단위로 설정가능
        - CreateTime(생성시간), 기본값
        - LogAppendTime(브로커 적재 시간)
- offset
    - 브로커에 적재될 때 오프셋 지정
        - 프로듀서가 생성한 레코드에는 없는 정보
    - 파티션별로 고유값
- headers
    - key/value
- key
    - 파티셔너에 따라 토픽의 파티션 번호가 정해짐
    - 기본값 : null > `round-robin`
    - 해쉬값
- value
### 클라이언트 메타데이터
> 카프카 클라이언트는 통신하고자 하는 리더 파티션의 위치를 알기 위해 데이터를 주고 받기 전에 메타데이터를 브로커로부터 전달받는다 

![스크린샷 2022-06-19 오후 10.07.05.png](https://github.zendesk.com/attachments/token/5dCWWFO1P5QwDrxzDSNRtCOSR/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+10.07.05.png)
- `metadata.max.age.ms` : 메타데이터 강제 리프레쉬. 기본값 5분
- `metadata.max.idle.ms` : 프로듀서가 유휴상태일 경우, 메타데이터 캐시 유지 기간. 기본값 5분

> 카프카 클라이언트는 반드시 리더 파티션과 통신해야 한다<br>
> 잘못된 브로커로 통신하면 `LEADER_NOT_AVAILABLE` 발생

![스크린샷 2022-06-19 오후 10.07.26.png](https://github.zendesk.com/attachments/token/3PtT8wGyF7LTprRNNsrVD06MG/?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2022-06-19+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+10.07.26.png)